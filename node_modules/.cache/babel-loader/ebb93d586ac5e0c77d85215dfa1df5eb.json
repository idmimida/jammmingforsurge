{"ast":null,"code":"const clientID = \"a6da220db2624ca192ba9aa8a9ef5485\";\nconst I = \"http://localhost:3000/\";\nlet accessToken;\nconst Spotify = {\n  getAccessToken() {\n    if (accessToken) {\n      return accessToken;\n    } //Check for an access token match\n\n\n    const accessTokenMatch = window.location.href.match(/access_token=([^&]*)/);\n    const expiresInMatch = window.location.href.match(/expires_in=([^&]*)/);\n\n    if (accessTokenMatch && expiresInMatch) {\n      accessToken = accessTokenMatch[1];\n      const expiresIn = Number(expiresInMatch[1]); //This clears the parameters, allowing us to grab a new access token when it expires\n\n      window.setTimeout(() => accessToken = \"\", expiresIn * 1000);\n      window.history.pushState(\"Access Token\", null, \"/\");\n      return accessToken;\n    } else {\n      const accessURl = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectURl}`;\n      window.location = accessURl;\n    }\n  },\n\n  search(term) {\n    const accessToken = Spotify.getAccessToken();\n    const endpoint = `https://api.spotify.com/v1/search?type=track&q=${term}`;\n    return fetch(endpoint, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`\n      }\n    }).then(response => {\n      if (response.ok) {\n        return response.json();\n      }\n    }).then(jsonResponse => {\n      if (!jsonResponse.tracks) {\n        return [];\n      } else {\n        return jsonResponse.tracks.items.map(track => ({\n          //为什么要有items??\n          id: track.id,\n          name: track.name,\n          artist: track.artists[0].name,\n          album: track.album.name,\n          uri: track.uri\n        }));\n      }\n    });\n  }\n\n};\nexport default Spotify;","map":{"version":3,"sources":["/Users/dan/Documents/Study/Coding/Frontend/JavaScript/Practice/ReactApp/jammming/src/util/Spotify.js"],"names":["clientID","I","accessToken","Spotify","getAccessToken","accessTokenMatch","window","location","href","match","expiresInMatch","expiresIn","Number","setTimeout","history","pushState","accessURl","redirectURl","search","term","endpoint","fetch","headers","Authorization","then","response","ok","json","jsonResponse","tracks","items","map","track","id","name","artist","artists","album","uri"],"mappings":"AAAA,MAAMA,QAAQ,GAAG,kCAAjB;AACA,MAAMC,CAAC,GAAG,wBAAV;AAEA,IAAIC,WAAJ;AAEA,MAAMC,OAAO,GAAG;AACdC,EAAAA,cAAc,GAAG;AACf,QAAIF,WAAJ,EAAiB;AACf,aAAOA,WAAP;AACD,KAHc,CAKf;;;AACA,UAAMG,gBAAgB,GAAGC,MAAM,CAACC,QAAP,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2B,sBAA3B,CAAzB;AACA,UAAMC,cAAc,GAAGJ,MAAM,CAACC,QAAP,CAAgBC,IAAhB,CAAqBC,KAArB,CAA2B,oBAA3B,CAAvB;;AAEA,QAAIJ,gBAAgB,IAAIK,cAAxB,EAAwC;AACtCR,MAAAA,WAAW,GAAGG,gBAAgB,CAAC,CAAD,CAA9B;AACA,YAAMM,SAAS,GAAGC,MAAM,CAACF,cAAc,CAAC,CAAD,CAAf,CAAxB,CAFsC,CAGtC;;AACAJ,MAAAA,MAAM,CAACO,UAAP,CAAkB,MAAOX,WAAW,GAAG,EAAvC,EAA4CS,SAAS,GAAG,IAAxD;AACAL,MAAAA,MAAM,CAACQ,OAAP,CAAeC,SAAf,CAAyB,cAAzB,EAAyC,IAAzC,EAA+C,GAA/C;AACA,aAAOb,WAAP;AACD,KAPD,MAOO;AACL,YAAMc,SAAS,GAAI,oDAAmDhB,QAAS,kEAAiEiB,WAAY,EAA5J;AACAX,MAAAA,MAAM,CAACC,QAAP,GAAkBS,SAAlB;AACD;AACF,GArBa;;AAuBdE,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,UAAMjB,WAAW,GAAGC,OAAO,CAACC,cAAR,EAApB;AACA,UAAMgB,QAAQ,GAAI,kDAAiDD,IAAK,EAAxE;AACA,WAAOE,KAAK,CAACD,QAAD,EAAW;AACrBE,MAAAA,OAAO,EAAE;AACPC,QAAAA,aAAa,EAAG,UAASrB,WAAY;AAD9B;AADY,KAAX,CAAL,CAIJsB,IAJI,CAIEC,QAAD,IAAc;AACpB,UAAIA,QAAQ,CAACC,EAAb,EAAiB;AACf,eAAOD,QAAQ,CAACE,IAAT,EAAP;AACD;AACF,KARM,EAQJH,IARI,CAQCI,YAAY,IAAI;AACpB,UAAI,CAACA,YAAY,CAACC,MAAlB,EAA0B;AACtB,eAAO,EAAP;AACH,OAFD,MAEO;AACH,eAAOD,YAAY,CAACC,MAAb,CAAoBC,KAApB,CAA0BC,GAA1B,CAA8BC,KAAK,KAAK;AAC3C;AACAC,UAAAA,EAAE,EAAED,KAAK,CAACC,EAFiC;AAG3CC,UAAAA,IAAI,EAAEF,KAAK,CAACE,IAH+B;AAI3CC,UAAAA,MAAM,EAAEH,KAAK,CAACI,OAAN,CAAc,CAAd,EAAiBF,IAJkB;AAK3CG,UAAAA,KAAK,EAAEL,KAAK,CAACK,KAAN,CAAYH,IALwB;AAM3CI,UAAAA,GAAG,EAAEN,KAAK,CAACM;AANgC,SAAL,CAAnC,CAAP;AAQH;AACJ,KArBM,CAAP;AAsBD;;AAhDa,CAAhB;AAmDA,eAAenC,OAAf","sourcesContent":["const clientID = \"a6da220db2624ca192ba9aa8a9ef5485\";\nconst I = \"http://localhost:3000/\";\n\nlet accessToken;\n\nconst Spotify = {\n  getAccessToken() {\n    if (accessToken) {\n      return accessToken;\n    }\n\n    //Check for an access token match\n    const accessTokenMatch = window.location.href.match(/access_token=([^&]*)/);\n    const expiresInMatch = window.location.href.match(/expires_in=([^&]*)/);\n\n    if (accessTokenMatch && expiresInMatch) {\n      accessToken = accessTokenMatch[1];\n      const expiresIn = Number(expiresInMatch[1]);\n      //This clears the parameters, allowing us to grab a new access token when it expires\n      window.setTimeout(() => (accessToken = \"\"), expiresIn * 1000);\n      window.history.pushState(\"Access Token\", null, \"/\");\n      return accessToken;\n    } else {\n      const accessURl = `https://accounts.spotify.com/authorize?client_id=${clientID}&response_type=token&scope=playlist-modify-public&redirect_uri=${redirectURl}`;\n      window.location = accessURl;\n    }\n  },\n\n  search(term) {\n    const accessToken = Spotify.getAccessToken();\n    const endpoint = `https://api.spotify.com/v1/search?type=track&q=${term}`;\n    return fetch(endpoint, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }).then((response) => {\n      if (response.ok) {\n        return response.json();\n      }\n    }).then(jsonResponse => {\n        if (!jsonResponse.tracks) {\n            return [];\n        } else {\n            return jsonResponse.tracks.items.map(track => ({\n                //为什么要有items??\n                id: track.id,\n                name: track.name,\n                artist: track.artists[0].name,\n                album: track.album.name,\n                uri: track.uri\n            }))\n        }\n    })\n  },\n};\n\nexport default Spotify;\n"]},"metadata":{},"sourceType":"module"}